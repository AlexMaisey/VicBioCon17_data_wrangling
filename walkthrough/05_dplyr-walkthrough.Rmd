---
title: "Dplyr: The basics"
author: "Elise Gould"
date: "09/01/2017"
output: github_document
---

```{r echo = FALSE, eval = TRUE, message=FALSE}
#Load package and data for knitting this document, but hide code from view
suppressPackageStartupMessages(library(tidyverse))
bat_dat <- read_csv(file = "../data/bat_dat.csv")
```

## What is 'dplyr', and why you should use it for data wrangling

Data wrangling is the messy process of cleaning, re-shaping and re-organising data from the raw format you imported into R into another format that allows for some analysis.

dplyr makes wrangling your data frames a breeze. dplyr is a metaphorical set of ‘pliers’ for wrangling your data frames, row- or column-wise subsetting, conduct group-wise operations on multiple subsets of data, or merge data frame and matching rows by value rather than position. 

Everything you can do in dplyr, you can do in base R. So why bother? dplyr is expressive, and verb-focused, rather than object-focused, meaning that common data manipulation problems take less code and less mental effort to write. This means it's easy for your collaborators (including your future-self) to read. This will become more apparent as you become more familiar with using dplyr on your own data. Moreover, much of dplyr’s work is implemented behind the scenes in C++ code, making wrangling larger data frames lightning-fast! 

## Dplyr, a "grammar" of data manipulation

### Learning our verbs and writing sentences:

- row-wise subsetting: `filter()` takes logical conditions as arguments
- column-wise subsetting: `select()` takes column names or tidyr functions to select matching columns

- Create new variables, change existing variables: `mutate()`
- summarise data with summary statistics: `summarise()`

- Reorder rows: `arrange()`
- Rename variables: `rename()`

### Dplyr verbs have a common syntax:

Each of the verbs above follow the same syntax:

- The first argument is a data-frame
- subsequent arguments describe what to do to that data frame, using the variable names (unquoted or 'bare'). Columns are referred to directly, without need to use the `$` operator.
- the function returns a new data frame
- input and output dataframes are *tidy* dataframes for all dplyr verbs (we will get to this in the [next module](./06_tidy_data.Rmd))

**Subsetting Observations (rows)**

Let's subset only the rows where Season is equal to 1. We use the `dplyr::filter()` function. 
- The first argument is the data frame we wish to filter through. 
- The second argument is a logical expression (two or more values separated by the [logical operators](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Logic.html): `==`, `!=`, `&`, `|`, etc., returning a logical, `TRUE` or `FALSE`). Try in console: `?Comparison` or `?base::logic`.

```{r filter-one-expression}
dplyr::filter(.data = bat_dat, Season == 1)
```

You can filter based on multiple variables. Let's get the sites from `Season 1`, and where there were more than 100 recordings of `Chgouldii`. How many sites are there where this was the case?

```{r filter-multiple-expresions}
dplyr::filter(.data = bat_dat, Season == 1, Chgouldii > 100)
```

Here are three other very useful filtering functions:

1. Remove duplicate rows with `dplyr::distinct()`
```{r distinct}
distinct(bat_dat) #no optional args given, uses all variables
distinct(bat_dat, Site) # give a variable as an argument, that var will determine uniqueness
```
2. Select rows by position with `dplyr::slice()`
```{r slice}
slice(bat_dat, 23)
slice(bat_dat, c(1:5, 11)) # More than one argument? concatenate
```

3. Get the top *n* entries with `dplyr::top_n()`
The second argument is *n*, and the third argument is the variable you wish to use for ordering.
```{r top-n}
top_n(bat_dat, 1 , Mmacropus)
```

**Subsetting Variables (Columns)**

Let's get only the following columns with `dplyr::select()`: `Site`, `Habitat`, `Season`, `Chgouldii`

```{r selecting}
dplyr::select(bat_dat, Site, Habitat, Season, Chgouldii)
```
We can also tell R that we wish it to drop some variables from our data:
```{r de-selecting-vars}
dplyr::select(bat_dat, -Humidity)
```

As well as using the bare column names to select a variable. We can also use a suite of helper functions to match column names. This is useful when we have many variables we wish to subset by, but want to minimise typing. For the full suite of helper functions, type `?select` in the console. Some important ones are:

- `contains()`
- `ends_with()`
- `starts_with()`
- `matches()`

```{r select-starts-with}
select(bat_dat, starts_with("dist")) # not case sensitive unless we tell R so
```

**Alter existing or create new variables with `mutate()`**
After the first data frame argument, `mutate()` takes one or more name-value pairs.
Which is simply the name of a new or existing variable, followed by an `=` and some expression making computations from existing variables.

- Add new variables:
Let's compute the sum of the counts for `Taustralis` and `Vdarlingtoni` species (call `View` for easy )
```{r mutate-new}
dplyr::mutate(bat_dat, Taust_Vdarl = Taustralis + Vdarlingtoni)
```
- Change existing ones:

To alter an existing variable we use the name of that variable in the name-value pair argument to `mutate()`, and then provide some computation to that variable on the right.

Imagine there was an error at some point during data collation and a decimal place was shifted, let's pretend it was for the variable `House500`. 


```{r mutate-existing}
mutate(bat_dat, House500 = House500 / 10)
```

**Make new variables summarised from existing variables**

Like mutate `summarise()` also uses name-value pairs of expressions. On the left-hand side is the name of the summary variable you wish to create, on the right hand side of the `=` is an expression that uses a summary function.

Sumary functions take a vector of values and return a single value, such as `mean()` or `sum()`. This can be represented visually by:
![summary_function](../assets/dplyr_summary_function.png)
Let's take the mean number of Chgouldii observations in 
```{r summarise}
summarise(bat_dat, mean_Chgouldii = mean(Chgouldii))
```
Observe how 188 observations have now been reduced to 1 value. Because the resultant vector is shorter than the input vector, this means we can no longer have a nice, square data frame, consequently, all other variables have been dropped.

Some key window functions include:

- `first()`
- `last()`
- `min()`
- `max()`
- statistical functions, like `median()`, `sd()`, `var()`. 

## Challenge @TODO

1. Renaming variables challenge
- I think this is in the tidyr challenge, but we could shift it here. Yes i think we should save reshaping data and some more complicated challenges for the tidy data one.
- we want to remove the spaces in some of the variables, you could approach this in different wasym but both are interactive type 'glimpse()' into the console and look visually. But chance you might miss some. Alternatively you can do it using a combination of programmatics and manually. The full programmatic way would probably pipe in the answer or have nested arguments. But leave this for now. we want people to use the helper functions... contains `" "` for space.
- also want them to remove dots, convert to underscores. same procedure, which ones had dots.
- do this in the tidy data script

# Writing sentences:

Often we want to combine actions, e.g. you might want to select and filter at the same time.

Making your code more readable, for future-you and other collaborators PUT THIS HERE OR PUT THIS IN A SECTION THAT BEGINS TO PIECE TOGETHER MULTIPLE DPLYR OPERATIONS?? E.g. http://seananderson.ca/2014/09/13/dplyr-intro.html

- Writing sentences, connecting your verbs: `%>%` pipe operator for connecting each operation into a pipeline.

Future-you is your closest collaborator. To make returning back to code you haven't looked at in ages a breeze, enter the pipe `%>%`.

The pipe simply passes an object on the left hand side as the first argument of a function on the right hand side. You can use them on any object within R, your object doesn't necessarily have to be a data frame. If you wish to pass the object on the left hand side as an argument other than the first, we type a `.` in place of the object within the function on the right hand side.

```
x %>% f(y) is the same as f(x,y)
y %>% f(x, ., z) is the same as f(x, y, z)
```
Here's a trivial example to help you get an idea of how they work, we'll use pipes all throughout the remainder of the workshop.

**A trivial example without pipes**

```{r no-pipes}

```


**And now with pipes**

```{r pipes}

```

How to read the code: say 'then' when you encounter the pipe at the end of each line.

**WHY pipes?**

Your code is more readable: 

- You dont have to read your functions from the inside out, so you can observe the sequence of operations more clearly and with little effort.
- You are less likely to create intermediate objects, so its easier to keep track of which object is the appropriate object to be working with

Your code is easier to write: 

- Your code is easier to type, flowing from one function to the next, just as your train of thought does
- You won't miss a closing bracket when you type your code with pipes


Your code is easier to debug: 

- you can run each operation line-by-line, isolating which part of your code is failing


### Grouped operations: Split, apply, combine operations


*Using window functions with `mutate()`*

`mutate()` uses window functions, which are functions that take a vector of values, and return another vector of values, with the output vector being the same length as the input vector. They are most useful when performing operations on groups of data.
For the full list of window functions, check out the Data Manipulation with dplyr and tidyr Cheatsheet:
`Help > Cheatsheets > Data Manipulation with dplyr, tidyr`
![From the data wrangling cheatsheet](../assets/dplyr_window_function.png)

*Using summary functions with `summarise()`*

At each site, get the number of Chgouldii observations (interested in looking at effect of season)

```{r}

```

For each season get the site with the highest number of Chgouldii observations.
```{r}

```



```{r}
bat_dat %>% select(1:19, -BatSpecies) %>% 
        mutate(check_bat_activity = Chgouldii +  `CG/Mormlp` + MormII + Mschocean + Nyctspp +  Mmacropus + `Nspp/Mmacr` + Scotspp. + Taustralis + Chmorio + Vdarlingtoni +  Vregulus +  Vvulturnus +  Unidentified)
```

# References and Resources

Dplyr and tidyr vignettes: type into R's console: `browseVignettes(package = c("dplyr", "tidyr"))`
